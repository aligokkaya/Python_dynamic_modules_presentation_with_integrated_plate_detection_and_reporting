<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import importlib
import os
import time
import zipfile
from datetime import datetime
from glob import glob

import cv2

from utils import Statics
from os import path
import logging
from zipfile import ZipFile
import os
from os.path import basename
import numpy as np
import re
from pathlib import Path
import zipfile
def input_img_searcher():
    &#34;&#34;&#34;Search STATICS.INPUT_FOLDER for the extensions (&#39;.jpg&#39;, &#39;.png&#39;, &#39;.jpeg&#39;, &#39;.bmp&#39;, &#39;.gif&#39;, &#39;.tiff&#39;, &#39;.webp&#39;)  recursively and create a dynamic dictionary
                Parameters:
                :parameter None
                Returns:
                :returns files_grabbed (dict): full list of file/folder of input imgs.

            &#34;&#34;&#34;
    files_grabbed = {}
    for dirpath, dirs, files in os.walk(Statics.INPUT_FOLDER):
        for filename in files:
            fname = os.path.join(dirpath, filename)
            if fname.endswith((&#39;.jpg&#39;, &#39;.png&#39;, &#39;.jpeg&#39;, &#39;.bmp&#39;, &#39;.gif&#39;, &#39;.tiff&#39;, &#39;.webp&#39;)):
                files_grabbed[filename]=fname
    Statics.FILES_GRABBED=files_grabbed
    return files_grabbed
def get_required_text(imgx):
    #print(Statics.INPUT_FOLDER+str(imgx))
    strx=Statics.INPUT_FOLDER+str(imgx)
    for m in Statics.RESULTSET:
        if m[&#34;img_name&#34;] == strx :
            return m[&#34;real_result&#34;]
def clear_text(str) :
    &#34;&#34;&#34;clear non alphanumeric chars
                        Parameters:
                        :parameter str (string): string to be cleared
                        Returns:
                        :returns str (string) : cleared string

        &#34;&#34;&#34;
    return re.sub(r&#39;\W+&#39;, &#39;&#39;, str)


def check_missing_python_packages():
    &#34;&#34;&#34;Search given package list (Statics.PACKAGES) in the environment , if import fails it will try to install these packages
            Parameters:
            :parameter None
            Returns:
            :returns None

        &#34;&#34;&#34;
    for package_name in Statics.PACKAGES:
        try:
            __import__(package_name)
            # import package_name
        except ImportError as error:
            Statics.LOGGER.logme(error.__class__.__name__ + &#34;: &#34; + str(error))
            Statics.LOGGER.logme(&#34;Trying to Install required module: &#34; + package_name + &#34;=&gt;  &#34; + Statics.PACKAGES[package_name][
                &#34;compatible_name&#34;] + &#34;\n&#34;)
            os.system(&#39;pip3 install &#39; + Statics.PACKAGES[package_name][&#34;compatible_name&#34;])
        try:
            __import__(package_name)
            # import package_name
        except ImportError:
            # add this package to requirements file, i do not like to force any system with a ready to use requirements file
            # in most cases i compile my own tensorflow and opencv thats why if system has a precompiled versions of packages there is no need to force it to update/install
            write_requirements_file(Statics.PACKAGES[package_name])


def write_requirements_file(details):
    &#34;&#34;&#34;Write requirements.txt file with missing system packages. Installation is straigtforward but on some systems it will fail to install.
    When this happens all dependency and requirements can be installed via
    &#34;pip3 install -r INPUT_OUTPUT/requirements.txt&#34;
    This file generated dynamically , if you have any package beforehand it will not add dependency on this file
    or it will not upgrade your versions.

         Parameters:
        :parameter  details (dict): Dictionary containing static module content from utils/Statics.py file
                        EXAMPLE :
                        &#34;version&#34;:-1,
                        &#34;compatible_name&#34;:&#34;opencv-python&#34;
        :returns None
     &#34;&#34;&#34;
    # first check if there is a requirements txt file
    if path.exists(Statics.REQUIREMENTS_FILE):
        # read and search for your package
        package_found = 0
        with open(Statics.REQUIREMENTS_FILE) as search:
            for line in search:
                line = line.rstrip()  # remove &#39;\n&#39;
                if line.startswith(details[&#34;compatible_name&#34;]):
                    package_found = 1
        if package_found == 0:
            with open(Statics.REQUIREMENTS_FILE, &#34;a&#34;) as f:
                f.write(&#34;\n&#34;)
                if details[&#34;version&#34;] == -1:
                    f.write(details[&#34;compatible_name&#34;])
                else:
                    f.write(details[&#34;compatible_name&#34;] + &#34;==&#34; + details[&#34;version&#34;])
                f.close()
    else:
        f = open(Statics.REQUIREMENTS_FILE, &#34;w&#34;)
        if details[&#34;version&#34;] == -1:
            f.write(details[&#34;compatible_name&#34;])
        else:
            f.write(details[&#34;compatible_name&#34;] + &#34;==&#34; + details[&#34;version&#34;])

        f.close()
def softmax( a):
    exps = np.exp(a.astype(np.float64))
    return exps / np.sum(exps, axis=-1)[:, np.newaxis]

def sigmoid( a):
    return 1. / (1. + np.exp(-a))
def image_resize(image, width = None, height = None, inter = cv2.INTER_NEAREST):
    # initialize the dimensions of the image to be resized and
    # grab the image size
    dim = None
    (h, w) = image.shape[:2]

    # if both the width and height are None, then return the
    # original image
    if width is None and height is None:
        return image

    # check to see if the width is None
    if width is None:
        # calculate the ratio of the height and construct the
        # dimensions
        r = height / float(h)
        dim = (int(w * r), height)

    # otherwise, the height is None
    else:
        # calculate the ratio of the width and construct the
        # dimensions
        r = width / float(w)
        dim = (width, int(h * r))

    # resize the image
    resized = cv2.resize(image, dim, interpolation = inter)

    # return the resized image
    return resized




def all_files(path):
    &#34;&#34;&#34;iterator returns all files and folders from path as absolute path string
    &#34;&#34;&#34;
    for child in Path(path).iterdir():
        yield str(child)
        if child.is_dir():
            for grand_child in all_files(str(child)):
                yield str(Path(grand_child))


def zip_dir(path):
    &#34;&#34;&#34;generate a zip&#34;&#34;&#34;
    zip_filename = &#39;old_results/TEST_RESULTS_&#39;+Statics.SESSION_STARTUP_TIME_STRING+&#39;.zip&#39;
    zip_file = zipfile.ZipFile(zip_filename, &#39;w&#39;)
    print(&#39;CREATED:&#39;, zip_filename)
    for file in all_files(path):
        print(&#39;adding... &#39;, file)
        zip_file.write(file)
    zip_file.write(Statics.LOG_FILE_NAME, basename(Statics.LOG_FILE_NAME))
    for file in all_files(Statics.REPORT_PATH+Statics.REPORTER_DATETIME):
        print(&#39;adding... &#39;, file)
        zip_file.write(file)


    zip_file.close()
def zip_outputs_logs(srcpath):
    &#34;&#34;&#34;Search given directory recursively and generate a ZIP file with the timestamp

            Parameters:

            :parameter srcpath (string): directory to zip and move to old_results

            Returns:
            :returns None

        &#34;&#34;&#34;
    try:
        os.makedirs(&#39;old_results/&#39;)
    except OSError as e:
        Statics.LOGGER.logme(str(e))
        zip_dir(srcpath,)






def module_loader(module_path):
    &#34;&#34;&#34;Search given directory recursively and load modules

        Parameters:

        :parameter module_path (string): Base Modules folder to scan/search recursively [modules]

        Returns:
        :returns None

    &#34;&#34;&#34;

    result = [y for x in os.walk(module_path) for y in glob(os.path.join(x[0], &#39;*.py&#39;))]
    Statics.LOGGER.logme(result)
    for str in result:
        str_class_name = os.path.basename(str)
        class_name = str_class_name.replace(&#34;.py&#34;, &#34;&#34;)
        str_clean = str.replace(&#34;.py&#34;, &#34;&#34;)

        module_name = str_clean.replace(os.sep, &#34;.&#34;)
        # module_name = module_name[0:int(module_name.rfind(&#39;.&#39;))]
        Statics.LOGGER.logme(&#34;MODULE_LOADER &#34;+ &#34; &#34;+module_name+&#34; &#34;+class_name)


        module = importlib.import_module(module_name)
        class_ = getattr(module, class_name)
        instance = class_()

        Statics.MODULES.append(instance)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.all_files"><code class="name flex">
<span>def <span class="ident">all_files</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>iterator returns all files and folders from path as absolute path string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_files(path):
    &#34;&#34;&#34;iterator returns all files and folders from path as absolute path string
    &#34;&#34;&#34;
    for child in Path(path).iterdir():
        yield str(child)
        if child.is_dir():
            for grand_child in all_files(str(child)):
                yield str(Path(grand_child))</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.check_missing_python_packages"><code class="name flex">
<span>def <span class="ident">check_missing_python_packages</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Search given package list (Statics.PACKAGES) in the environment , if import fails it will try to install these packages
Parameters:
:parameter None
Returns:
:returns None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_missing_python_packages():
    &#34;&#34;&#34;Search given package list (Statics.PACKAGES) in the environment , if import fails it will try to install these packages
            Parameters:
            :parameter None
            Returns:
            :returns None

        &#34;&#34;&#34;
    for package_name in Statics.PACKAGES:
        try:
            __import__(package_name)
            # import package_name
        except ImportError as error:
            Statics.LOGGER.logme(error.__class__.__name__ + &#34;: &#34; + str(error))
            Statics.LOGGER.logme(&#34;Trying to Install required module: &#34; + package_name + &#34;=&gt;  &#34; + Statics.PACKAGES[package_name][
                &#34;compatible_name&#34;] + &#34;\n&#34;)
            os.system(&#39;pip3 install &#39; + Statics.PACKAGES[package_name][&#34;compatible_name&#34;])
        try:
            __import__(package_name)
            # import package_name
        except ImportError:
            # add this package to requirements file, i do not like to force any system with a ready to use requirements file
            # in most cases i compile my own tensorflow and opencv thats why if system has a precompiled versions of packages there is no need to force it to update/install
            write_requirements_file(Statics.PACKAGES[package_name])</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.clear_text"><code class="name flex">
<span>def <span class="ident">clear_text</span></span>(<span>str)</span>
</code></dt>
<dd>
<div class="desc"><p>clear non alphanumeric chars
Parameters:
:parameter str (string): string to be cleared
Returns:
:returns str (string) : cleared string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_text(str) :
    &#34;&#34;&#34;clear non alphanumeric chars
                        Parameters:
                        :parameter str (string): string to be cleared
                        Returns:
                        :returns str (string) : cleared string

        &#34;&#34;&#34;
    return re.sub(r&#39;\W+&#39;, &#39;&#39;, str)</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.get_required_text"><code class="name flex">
<span>def <span class="ident">get_required_text</span></span>(<span>imgx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_text(imgx):
    #print(Statics.INPUT_FOLDER+str(imgx))
    strx=Statics.INPUT_FOLDER+str(imgx)
    for m in Statics.RESULTSET:
        if m[&#34;img_name&#34;] == strx :
            return m[&#34;real_result&#34;]</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.image_resize"><code class="name flex">
<span>def <span class="ident">image_resize</span></span>(<span>image, width=None, height=None, inter=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image_resize(image, width = None, height = None, inter = cv2.INTER_NEAREST):
    # initialize the dimensions of the image to be resized and
    # grab the image size
    dim = None
    (h, w) = image.shape[:2]

    # if both the width and height are None, then return the
    # original image
    if width is None and height is None:
        return image

    # check to see if the width is None
    if width is None:
        # calculate the ratio of the height and construct the
        # dimensions
        r = height / float(h)
        dim = (int(w * r), height)

    # otherwise, the height is None
    else:
        # calculate the ratio of the width and construct the
        # dimensions
        r = width / float(w)
        dim = (width, int(h * r))

    # resize the image
    resized = cv2.resize(image, dim, interpolation = inter)

    # return the resized image
    return resized</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.input_img_searcher"><code class="name flex">
<span>def <span class="ident">input_img_searcher</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Search STATICS.INPUT_FOLDER for the extensions ('.jpg', '.png', '.jpeg', '.bmp', '.gif', '.tiff', '.webp')
recursively and create a dynamic dictionary
Parameters:
:parameter None
Returns:
:returns files_grabbed (dict): full list of file/folder of input imgs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input_img_searcher():
    &#34;&#34;&#34;Search STATICS.INPUT_FOLDER for the extensions (&#39;.jpg&#39;, &#39;.png&#39;, &#39;.jpeg&#39;, &#39;.bmp&#39;, &#39;.gif&#39;, &#39;.tiff&#39;, &#39;.webp&#39;)  recursively and create a dynamic dictionary
                Parameters:
                :parameter None
                Returns:
                :returns files_grabbed (dict): full list of file/folder of input imgs.

            &#34;&#34;&#34;
    files_grabbed = {}
    for dirpath, dirs, files in os.walk(Statics.INPUT_FOLDER):
        for filename in files:
            fname = os.path.join(dirpath, filename)
            if fname.endswith((&#39;.jpg&#39;, &#39;.png&#39;, &#39;.jpeg&#39;, &#39;.bmp&#39;, &#39;.gif&#39;, &#39;.tiff&#39;, &#39;.webp&#39;)):
                files_grabbed[filename]=fname
    Statics.FILES_GRABBED=files_grabbed
    return files_grabbed</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.module_loader"><code class="name flex">
<span>def <span class="ident">module_loader</span></span>(<span>module_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Search given directory recursively and load modules</p>
<p>Parameters:</p>
<p>:parameter module_path (string): Base Modules folder to scan/search recursively [modules]</p>
<p>Returns:
:returns None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def module_loader(module_path):
    &#34;&#34;&#34;Search given directory recursively and load modules

        Parameters:

        :parameter module_path (string): Base Modules folder to scan/search recursively [modules]

        Returns:
        :returns None

    &#34;&#34;&#34;

    result = [y for x in os.walk(module_path) for y in glob(os.path.join(x[0], &#39;*.py&#39;))]
    Statics.LOGGER.logme(result)
    for str in result:
        str_class_name = os.path.basename(str)
        class_name = str_class_name.replace(&#34;.py&#34;, &#34;&#34;)
        str_clean = str.replace(&#34;.py&#34;, &#34;&#34;)

        module_name = str_clean.replace(os.sep, &#34;.&#34;)
        # module_name = module_name[0:int(module_name.rfind(&#39;.&#39;))]
        Statics.LOGGER.logme(&#34;MODULE_LOADER &#34;+ &#34; &#34;+module_name+&#34; &#34;+class_name)


        module = importlib.import_module(module_name)
        class_ = getattr(module, class_name)
        instance = class_()

        Statics.MODULES.append(instance)</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.sigmoid"><code class="name flex">
<span>def <span class="ident">sigmoid</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sigmoid( a):
    return 1. / (1. + np.exp(-a))</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.softmax"><code class="name flex">
<span>def <span class="ident">softmax</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def softmax( a):
    exps = np.exp(a.astype(np.float64))
    return exps / np.sum(exps, axis=-1)[:, np.newaxis]</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.write_requirements_file"><code class="name flex">
<span>def <span class="ident">write_requirements_file</span></span>(<span>details)</span>
</code></dt>
<dd>
<div class="desc"><p>Write requirements.txt file with missing system packages. Installation is straigtforward but on some systems it will fail to install.
When this happens all dependency and requirements can be installed via
"pip3 install -r INPUT_OUTPUT/requirements.txt"
This file generated dynamically , if you have any package beforehand it will not add dependency on this file
or it will not upgrade your versions.</p>
<pre><code> Parameters:
:parameter  details (dict): Dictionary containing static module content from utils/Statics.py file
                EXAMPLE :
                "version":-1,
                "compatible_name":"opencv-python"
:returns None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_requirements_file(details):
    &#34;&#34;&#34;Write requirements.txt file with missing system packages. Installation is straigtforward but on some systems it will fail to install.
    When this happens all dependency and requirements can be installed via
    &#34;pip3 install -r INPUT_OUTPUT/requirements.txt&#34;
    This file generated dynamically , if you have any package beforehand it will not add dependency on this file
    or it will not upgrade your versions.

         Parameters:
        :parameter  details (dict): Dictionary containing static module content from utils/Statics.py file
                        EXAMPLE :
                        &#34;version&#34;:-1,
                        &#34;compatible_name&#34;:&#34;opencv-python&#34;
        :returns None
     &#34;&#34;&#34;
    # first check if there is a requirements txt file
    if path.exists(Statics.REQUIREMENTS_FILE):
        # read and search for your package
        package_found = 0
        with open(Statics.REQUIREMENTS_FILE) as search:
            for line in search:
                line = line.rstrip()  # remove &#39;\n&#39;
                if line.startswith(details[&#34;compatible_name&#34;]):
                    package_found = 1
        if package_found == 0:
            with open(Statics.REQUIREMENTS_FILE, &#34;a&#34;) as f:
                f.write(&#34;\n&#34;)
                if details[&#34;version&#34;] == -1:
                    f.write(details[&#34;compatible_name&#34;])
                else:
                    f.write(details[&#34;compatible_name&#34;] + &#34;==&#34; + details[&#34;version&#34;])
                f.close()
    else:
        f = open(Statics.REQUIREMENTS_FILE, &#34;w&#34;)
        if details[&#34;version&#34;] == -1:
            f.write(details[&#34;compatible_name&#34;])
        else:
            f.write(details[&#34;compatible_name&#34;] + &#34;==&#34; + details[&#34;version&#34;])

        f.close()</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.zip_dir"><code class="name flex">
<span>def <span class="ident">zip_dir</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>generate a zip</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip_dir(path):
    &#34;&#34;&#34;generate a zip&#34;&#34;&#34;
    zip_filename = &#39;old_results/TEST_RESULTS_&#39;+Statics.SESSION_STARTUP_TIME_STRING+&#39;.zip&#39;
    zip_file = zipfile.ZipFile(zip_filename, &#39;w&#39;)
    print(&#39;CREATED:&#39;, zip_filename)
    for file in all_files(path):
        print(&#39;adding... &#39;, file)
        zip_file.write(file)
    zip_file.write(Statics.LOG_FILE_NAME, basename(Statics.LOG_FILE_NAME))
    for file in all_files(Statics.REPORT_PATH+Statics.REPORTER_DATETIME):
        print(&#39;adding... &#39;, file)
        zip_file.write(file)


    zip_file.close()</code></pre>
</details>
</dd>
<dt id="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.zip_outputs_logs"><code class="name flex">
<span>def <span class="ident">zip_outputs_logs</span></span>(<span>srcpath)</span>
</code></dt>
<dd>
<div class="desc"><p>Search given directory recursively and generate a ZIP file with the timestamp</p>
<p>Parameters:</p>
<p>:parameter srcpath (string): directory to zip and move to old_results</p>
<p>Returns:
:returns None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip_outputs_logs(srcpath):
    &#34;&#34;&#34;Search given directory recursively and generate a ZIP file with the timestamp

            Parameters:

            :parameter srcpath (string): directory to zip and move to old_results

            Returns:
            :returns None

        &#34;&#34;&#34;
    try:
        os.makedirs(&#39;old_results/&#39;)
    except OSError as e:
        Statics.LOGGER.logme(str(e))
        zip_dir(srcpath,)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils" href="index.html">HasanSARMAN_PLAKA_OKUMA.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.all_files" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.all_files">all_files</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.check_missing_python_packages" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.check_missing_python_packages">check_missing_python_packages</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.clear_text" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.clear_text">clear_text</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.get_required_text" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.get_required_text">get_required_text</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.image_resize" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.image_resize">image_resize</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.input_img_searcher" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.input_img_searcher">input_img_searcher</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.module_loader" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.module_loader">module_loader</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.sigmoid" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.sigmoid">sigmoid</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.softmax" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.softmax">softmax</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.write_requirements_file" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.write_requirements_file">write_requirements_file</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.zip_dir" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.zip_dir">zip_dir</a></code></li>
<li><code><a title="HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.zip_outputs_logs" href="#HasanSARMAN_PLAKA_OKUMA.utils.UtilsGeneric.zip_outputs_logs">zip_outputs_logs</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>